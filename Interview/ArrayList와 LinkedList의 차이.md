List
- 선형적인 자료구조
- 데이터를 일렬로 늘여놓은 형태
- 순서

ArrayList vs LinkedList


ArrayList
---

- 배열 기반의 리스트
- 인덱스 기반의 리스트이기 때문에 인덱스의 위치만 알고 있다면 동일한 시간으로 해당 인덱스까지 접근가능하다.
- 실제 메모리 공간을 연속적으로 사용하여 컴퓨터가 연산에 용이하다.
- 데이터 insert
    - 맨끝의 경우 배열의 크기가 초과화지 않는이상 맨 뒤에 추가 - O(1)
    - 데이터의 중간에 추가하는 경우 데이터들은 한칸씩 뒤로 미룬 뒤 insert하려는 인덱스에 데이터를 넣어야한다.
    - Array의 크기가 꽉 차 있는 경우 배열을 늘려야 하기 때문에 O(n)만큼의 시간 복잡도를 갖는다.
- 데이터 delete
    - 중간에 있는 인덱스의 데이터를 삭제하는 경우 해당 인덱스의 데이터 삭제 후 그 뒤에 있는 인덱스들을 한칸 앞으로 끌어와야하기 때문에 O(n)만큼의 시간복잡도를 갖는다.
- 데이터 탐색
    - ArrayList는 탐색의 방법이 Random Access 방식이기 때문에  탐색을 할때 위치에 관계없이 O(1)의 시간복잡도를 갖는다.

LinkedList
---

- LinkedList 각 데이터를 node의 형태로 갖고있다.
- 가장 앞에있는 노드를 Head, 가장 끝에 있는 노드는 Tail로 표시한다.
- 데이터를 논리적으로 연결시켜 메모리상에서는 연속적으로 이어져있지않다.
- 배열의 복사나 재할당 없이 데이터 추가가 가능하다.
- Array 의 경우 배열 내에 데이터가 없는 인덱스가 있더라도 공간을 차지하고 있기 때문에 그에 반해 LinkedList 필요한 노드만 가지고 있어 유연한 공간을 가질 수 있다.

- 데이터 탐색
    - 자신을 가리키고 있는 포인터로만 이동이 가능하기 때문에 Head에서 Tail까지 끝까지 순회하면서 데이터를 찾는 방법밖에 없다. 시간복잡도는 O(n)
- 데이터 insert
    - 맨 끝에 데이터를 넣는 경우 Head 에서 Tail까지 찾아가며 끝에 데이터를 넣어야하기 때문에 O(n)의 시간복잡도를 가지며, 중간에 넣는 경우에도 중간까지의 위치를 찾아가야 하기 떄문에 시간복잡도는 동일하다. 
    - 그러나 ArrayList와 다르게 데이터를 넣는 위치의 뒤에 노드들을 다 밀어줄 필요는 없으며 insert되는 노드의 previous 노드는 데이터를 넣는 자신을 가리키게 하고 자신의 노드는 다음으로 이동할 next 노드를 가리치게 변경 해주어야 한다.
    - LinkedList의 맨앞에 놓이는 경우 다음 노드를 가리키게만 해주면 된다.
- 데이터 delete
    - insert와 동일하게 지우고자 하는 데이터까지 찾아가야하기 때문에 시간복잡도는 동일하게 O(1)이다.
    - 삭제되는 노드의 previous 노드는 다음 노드로 삭제되는 노드를 가리키고 있기 때문에 삭제되는 노드의 next 노드를 가리키게만 해주면 된다. 
    - 삭제된 노드는 LinkedList의 연결에서 끊겨 아무런 효용가치가 없어졌기 때문에 GC가 처리한다.




⭐ Keyword
임의 접근, random access
기억 장치에서 자료를 읽거나 쓸 때 기억 장소에 관계없이 동일한 접근 시간이 걸리는 접근 방식. 즉, 기억 장치에 저장된 자료를 순차적으로 접근하지 않고 거의 동일한 시간 내에 임의의 장소를 찾아 접근할 수 있는 방식이다.