오버로딩
=============


오버로딩 정의
-------------

>**생성자** 오버로딩 이란 매개변수를 달리하는 **생성자** 여러 개 선언하는 것   
>**메소드** 오버로딩 이란 매개변수를 달리하는 **메소드** 여러 개 선언하는 것

<br>

오버로딩을 사용하는 이유?
-------------
이름은 같지만 다른 매개변수값으로 객체의 필드를 다양하게 초기화하거나 (생성자 오버로딩)   
이름은 같지만 다른 매개변수값으로 메소드를 중복으로 선언할 때 사용한다 (메소드 오버로딩)

<br>

생성자 오버로딩 예제
-------------

```Java
public class Car {
    String model;
    String color;
    int carNumber;

    //생성자 선언
    public Car() {
        //기본생성자
    }

    public Car(String model) {
        this.model = model;
    }

    public Car(String model, String color) {
        this.model = model;
        this.color = color;
    }

    public Car(String model, String color, int carNumber) {
        this.model = model;
        this.color = color;
        this.carNumber = carNumber;
    }
}
```

<br>

생성자 오버로딩 에러 예제
-------------
```java
// 매개변수의 순서만 다르고 인자값이 같음
public Car(String model, String color) {
        this.model = model;
        this.color = color;
    }

public Car(String color, String model) {
        this.model = model;
        this.color = color;
    }
//'Car(String, String)'이(가) 'ch08.Car'에 이미 정의되어 있습니다.
```

<br>

메소드 오버로딩 예제
-------------
```java
public double areaRectangle(double width){
    //정사각형의 넓이
    return width * width;
}
public double areaRectangle(double width, double height){
    // 직사각형의 넓이
    return width * height;
}
```

<br>

메소드 오버로딩 에러예제 
-------------
```java
public void showCarInfo(String model){
        System.out.println("모델명은 " + model + "입니다.");
    }

/* 매개변수가 String 타입으로 동일하여 불가
public void showCarInfo(String color){
    System.out.println("컬러는 " + color + "입니다.");
}
error message : 'showCarInfo(String)'이(가) 'ch08.Car'에 이미 정의되어 있습니다
*/

// 매개변수의 타입이 다른 경우 가능
public void showCarInfo(int carNumber){
        System.out.println("차 번호는 " + carNumber + "입니다.");
    }
```

메소드 오버로딩의 경우 이름은 같고 메소드의 인자값은 달라야한다.


***
<br>
   


오버라이딩
=============


객체지향의 상속(Inheritance)
----
> 부모 클래스의 필드와 메소드를 자식 클래스에게 물려주는 행위

```java
// A.java
public class A {
    String field1;
    void methodA(){···}
}
// B.java
public Class B extends A {
    String field2;
    void methodB(){···}
    // Class B 에서 A의 field1, methodA를 가지고 있는 것 처럼 보인다.
}
```

<br>

오버라이딩 정의
-------------
부모 클래스의 메소드를 자식 클래스에서 상속 받아 사용해야 하는 경우가 있다. 하지만 부모의 메소드가 자식 클래스에서 사용하기에 적합하지 않은 경우 메소드를 재정의 하여 사용하는 것을 메소드 오버라이딩이라고 한다.

<br>

오버라이딩 규칙
----
- 부모 메소드의 선언부(리턴 타입, 메소드 이름, 매개변수)가 동일해야한다.
- 접근 제한을 더 강하게 오버라이딩할 수 없다. (public > default > protected > private)  
 ( ex : 부모클래스의 메소드 private 인 경우 자식클래스의 메소드 public, default, protected 가능)
- 새로운 예외를 throws할 수 없다.

<br>

오버라이딩 예제
---

```java 
// Calculator.java
public class Calculator {
    public double areaCircle(double r) {
        return Math.PI * r * r;
    }
}
// Computer.java
public class Computer extends Calculator{

    @Override // 오버라이딩이 되었다는 표시 (생략가능)
    public double areaCircle(double r) {
        double area = Math.PI * r * r;
        return Math.round(area*100)/100.0;
    }
}

//ComputerTest.java
public class ComputerTest {
    public static void main(String[] args) {
        Calculator ca = new Calculator();
        System.out.println(ca.areaCircle(5));
        
        Computer com = new Computer();
        System.out.println(com.areaCircle(5));
     
    }
}
```
> 78.53981633974483  
 78.54


<br>

정리
---
오버로딩과 오버라이딩의 차이는 완전 다른 기능이기 때문에 이름이 비슷하여 혼동할 수 있어 각 기능에 대해 숙지해야한다.




