# 클린 코드가 코드에 대한 책이 아닌 사실에 대해 (박성철, 컬리 물류 프도덕트 본부장)

## 클린 코드에 대한 오해

### 클린?
- 어떤 상태가 있다는 착각
- 부울 조건? 클린한가? 더러운가? 그것이 문제이다..
- 죄책감, 결벽증, 강박장애
- 본말전도, 클린코드가 목적이 되어버린다.
- 오독하게 만들거나 오해하게 만든다.

## 소프트웨어 설계란 무엇인가

설계 -> 코딩 -> 실행
옛날에 개발자들은 설계한 내용을 만들기만 하면되는 코더에 가까웠다.

### AI 시대에 코딩은 계속 필요한가? 

"코드의 종말이 코앞에 닥쳤다고 주장하는 사람이 없지 않다. <중략> 앞으로 코드가 사라질 가망은 전혀 없다.
왜? **코드는 요구 사항을 상세히 표현하는 수단이니까** - 로버트 C. 마틴, <클린코드>

### 설계 과정으로서 코딩

> 프로그래밍은 소프트웨어를 만드는 것이 아니라 소프트웨어를 설계하는 것이다.

- 소프트웨어 구축 비용이 무료에 가깝다. 소프트웨어 구축은 컴파일러와 링커에 의해 이루어진다.
- 소프트웨어 설계를 (타 공학에 비해) 비교적 쉽게 만들 수 있다.
- 엔지니어가 처음부터 완벽하게 설계하기를 기대하는 사람은 아무도 없다.
- 코딩도 설계이고, 테스트와 디버깅도 설계의 일부이며, 우리가 일반적으로 소프트웨어 설계라고 부르는 것 역시 설계의 일부이다.

## OOP를 바라보는 관점

- 명사(데이터) 중심
  - 데이터를 중심으로 관련 절차(함수)를 캡슐화
  - OOAD와 자료구조로서 객체의 관점
  - er로 끝나는 이름 금기
- 동사(기능) 중심
  - 객체를 작은 컴퓨터(입력과 출력)로 보는관점
  - 메시징과 객체 간 협력 강조
  - 상태는 지역적으로 은닉됨(Tell, Don`t Ask)
- 객체 중심
  - 큰 객체 : 세부는 타 프로그래밍 스타일 사용
  - 대부분의 주요 OOP 프로그래밍 언어
- 객체 보조
  - 자료 구조 또는 추상 자료형 관점 객체 활용(CLU, CLOS, OCaml)
  - 토이 호어의 레코드 처리

## 클린 코드의 OOP
- 메시지(동사) 중심, 큰 객체
- OOP와 다른 패러다임 (예,FP,절차적 프로그래밍)의 적절한 혼용 제안

### 자바 8 이후, 주요 개선 방향
- 프로젝트 람다와 앰버
- 자바 8-11
  - 람다, 함수 인터페이스, 메서드 참조, 기본 구현, 스트림
  - 값 기반 클래스(Optional, LocalDateTime ...) -> 향후 값 객체 발전
  - 반응형 스트림, REPL(jshell), 지역 변수 타입 추론
- 자바 12-17
  - 스위치식, 패턴 매칭, 레코드, 봉인 클래스
- 자바 18-21
  - 스위치식 패턴 매칭, 레코드 패턴

### 데이터 지향 프로그래밍(DOP)
- 전통적인 데이터와 데이터 변환 분리 방식
- OOP의 한계: *비지터 패턴
- OO의 데이터 - 행위 캡슐화 반대
  - 데이터 의존성에 행위 의존성이 더해져 복작도 증가
  - 메시지(동사) 중심, 큰 객체 OOP와는 잘 맞음
- 자바 아키텍츠 브라이언 게츠 DOP 제안
  - 여러 패러다임을 접목하여 개발하라.

# 설계

클린 코드의 흔한 오해 - "처음부터 클린 코드를 작성하면 리팩터링이 필요 없다."

## 리-팩터링

> 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법"

- 팩터링(factoring) = 인수 분해 = 분해(decomposition) = 설계
- 리팩터링 = 재설계

## 기회주의 리팩터링

계획을 세워서 리팩토링 작업을 진행하는 경우도 있지만, 
나는 리팩토링을 언제 어디서나 코드를 정리해야 할 때 누구든 할 수 있는 기회주의 활동으로 장려하고 싶다. - 마틴파울러

## 왜 리팩터링을 안할까?

누구나 예기하지만 아무도 해본 적 없는?

### 테스트와 리팩터링

실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다.
테스트는 유연성, 유지보수성, 재사용성을 제공한다.
**테스트 케이스가 있으면 변경이 쉬워지기 떄문이다.**

### TDD와 리팩터링

이 책(디자인 패턴)은 **설계를 독립된 단계**로 바라보는 성향을 어렴풋이 띈다.
이 책은 확실히 **리팩터링을 설계의 일종**으로 보는 것에 동의하지 않는다.
TDD에서는 설계를 디자인 패턴과는 조금 다른 관점으로 본다.

적극적 리팩터링을 진행한다
1. 테스트를 먼저 작성
2. 코드가 없기 떄문에 테스트 실패 -> 코드를 러프하게 구현한다.
3. 테스트 성공

개발하면서 계속 설계하는 것이 TDD이다.

### DDD의 리팩토링

- 심층적인 통찰력을 향한 리팩터링
- 지속적인 리팩터링 과정에서 암시적인 개념을 인식하면서 어느 순간 모든 것을 뒤흔드는 통찰력을 얻게 됨.
- 도약 : 생물 세계의 급작스러운 진화, 소프트웨어의 진화도 일정하지 않다. (광범위한 대규모 리팩토링)
- 도약 후 다시 지속적인 리팩토링 시작

### 창발적 설계

창발 : 의도하지 않은것이 툭 튀어나온

켄트 백의 단순한 설계 규칙
1. 모든 테스트를 실행한다.
2. 중복을 없앤다
3. 프로그래머의 의도를 표현한다.
4. 클래스와 메서드 수를 최소로 줄인다.

좋은 설계(클린 코드)의 창발

분리된 사전 설계 -> 설계로서 코딩 (빌드 자동화) -> 리팩터링(설계 개선) -> 적극적 리팩터링(상시 설계) (테스트 코드) -> 창발적 설계

# 아키텍처

## 아키텍처 수립 시기

시스템에 오랫동안 큰 영향을 미치므로 초기에 심사숙고하여 결정해야 한다?

## 성장하는 아키텍처?

초기에 어느 단계에서 설계할 수 있도록
아키텍처를 시작하기 충분할 정도로만 만들고 꾸준히 다듬어 나가야한다.

## 결정 미루기

문제를 나누고 정복하지 않고, 문제에 대해 정복하고 나누고 또 정복 한다.
소규모 시스템을 작성 후 자연스러운 분할선을 찾아 비교적 독립적인 부분을 나눠 확장한다.

## 제작과 사용의 분리

소프트웨어 시스템은 물리적인 시스템과 다르다.
관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.

스프링이 모듈화가 잘되어있고 각 모듈별로 따로 쓸 수 있기 때문에 인기가 많아진 것이다.

## 테스트와 아키텍처

아키텍트는 대규모 리팩터링을 찾아서 실행하고


# 정리
- 클린 코드는 생각보다 클린이나 코드와 상관 없을지도
  - 클린? 중용, 실용주의, 무엇이든 교조적으로 따르지 않도록 노력하자
  - 코드? 코드는 최종 설계 산출물이다.
- OOP와 FP 외의 다양하 프로그래밍 스타일 가능성
- 꾸준히 성장하고 분화하는 소프트웨어(자가 증식 & 포식)
- **테스트 코드를 중심으로 변화 주기를 만들자(테스트 = 안전망)** 나를 위한 테스트 코드를 만들자

