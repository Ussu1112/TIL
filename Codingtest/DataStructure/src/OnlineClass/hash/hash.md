## 해시 자료구조

- 데이터를 빠르게 저장하고 가져오는 기법 중 하나
- KEY(VALUE를 구분하는 값)와 VALUE(저장하려는 값)로 구성
- Key 값을 HashFunction에 넣어 그에 해당하는 Value 값을 찾는다.
- HashFunction 키를 입력으로 넣어주면 해싱값을 출력하고 해시값을 인덱싱하여 데이터를 저장한다.
- 키에 특정 연산(Hash Function)을 적용하여 테이블(Hash Table)의 주소를 계산

### HashTable
- (Key, Value) 쌍을 저장
- 데이터상 순서가 존재하지 않는다.

### Hashing - Key
- 키를 기준으로 값을 매핑
- 고유한 값
  - 중복 불가
  - 사람 이름, 아이디 등 중복이 가능한 데이터가 아닌 주민번호 같은 고유한 값을 사용해야 한다.

### Hashing - Hash Function
- 임의의 데이터(키)를 특정 값(해시값)으로 매핑시키는 함수
- Hash Function을 통한 데이터 접근 시 키 값을 알고 있기 때문에 O(1)의 시간복잡도를 갖는다.
- 좋은 해시 함수란?
  - 키 값을 고르게 분포 시킴
  - 빠른 계산
  - 충돌 최소화

### 해시 충돌
- 키 값이 다른데, 해시 함수의 결과값이 동일한 경우
- 해시충돌은 필연적으로 발생할 수 밖에 없다.. 최소한으로 만들어야함

- 비둘기 집 원리
  - N+1 개의 물건을 N개의 상자에 넣을 때 적어도 어느 한 상자에는 두 개 이상의 물건이 들어있다.
  - 해시 테이블에서는 인덱스의 수가 한정되어 있지만 키를 만들어내는 건 무한히가능하기 때문에 충돌이 발생할 수 있다.
- Birthday Problem
  - 임의의 사람 N명이 모였을 때 그 중에 생일이 같은 두 명이 존재할 확률
  - 생일의 가짓수는 2월 29일 포함 366개 
  - 23명만 모여도 50.7% 확률로 존재 50명인 경우는 97%에 달한다.

### 해시 충돌 해결방법

#### 체이닝
- 동일한 키 값이 삽입 되는 경우 데이터가 저장되어있는 Bucket에 LinkedList의 형태로 데이터를 이어붙혀 저장한다.
- 체이닝을 통해 데이터를 저장하는 경우 여러개의 Bucket으로 묶인 리스트 형태의 데이터를 검색하기 위해서는 순차탐색을 해야하기 때문에 최악의 경우 O(n)의 시간 복잡도를 가지게 된다.
- 그래서 리스트 대신 트리구조를 사용하여 구성한다.

#### Open Addressing
- 선형 탐색
  - 해시 충돌 시 n칸을 건너뛴 다음 버킷에 저장
  - 계산이 단순해진다.
  - 대신 검색 시간이 많이 소요된다. (최대 O(n))
  - 데이터들이 특정 위치에만 밀집 될 수 있다.(clustering; 클러스터링)

- 제곱 탐색
  - 클러스터링을 피하기 위해
  - N^2(1,4,9,16,...)을 건너뛴 버킷에 데이터 저장
  - 데이터들이 특정위치에 밀집하는 문제를 해결
  - 하지만 처음 해시 값이 같다면 여전히 O(n)번의 탐색은 피할 수가 없다.

- 이중 해시
  - 해시 값에 다른 해시 함수를 한번 더 적용
  - Hashfunction1() : 최초의 해시 값을 구함
  - Hashfunction2() : 충돌 발생 시 이동 폭을 구함
  - 최초 해시 값이 같더라도 이동 폭이 다르기 때문에 clustering문제를 해결 가능하다.



